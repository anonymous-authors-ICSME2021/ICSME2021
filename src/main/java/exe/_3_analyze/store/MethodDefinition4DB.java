package exe._3_analyze.store;

import beans.refactoring.Refactoring2;
import beans.source.MethodDefinition;
import beans.source.TestMethodDefinition;
import gr.uom.java.xmi.UMLAbstractClass;
import gr.uom.java.xmi.UMLOperation;

import org.refactoringminer.api.Refactoring;

import java.io.Serializable;
import java.util.*;

import javax.persistence.*;

/**
 * This class is used for storing data into database
 */
@Entity
@Table(name = "MethodDefinition", schema = "ia", uniqueConstraints = { @UniqueConstraint(columnNames = { "md_id"}) })
public class MethodDefinition4DB implements Serializable{
    /**
     * This id is automatically generated by hibernate
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name="md_id", columnDefinition="bigint")
    public long md_Id;
    /**
     * This is method's signature (i.e., filename, class name, method name, parameter types)
     */
    @Column(name="signature", columnDefinition="TEXT")
    public String signature;
    /**
     * This is method's signature (i.e., filename, class name, method name, parameter types) after/before refactoring
     * Sometimes, signature is modified by Rename, Move refactoring
     * This makes us difficult to link the method between two snapshots.
     * Thus, we link them with refactoring miner
     */
    @Column(name="anotherSignature", columnDefinition="TEXT")
    public String anotherSignature;
    /**
     * file name
     */
    @Column(name="fileName", columnDefinition="TEXT")
    public String fileName;
    /**
     * class name
     */
    @Column(name="className", columnDefinition="TEXT")
    public String className;
    /**
     * package name
     */
    @Column(name="packageName", columnDefinition="TEXT")
    public String packageName;
    /**
     * method name
     */
    @Column(name="methodName", columnDefinition="TEXT")
    public String methodName;
    /**
     * annotations (e.g., @Test)
     */
    @ElementCollection(targetClass = String.class)
    @CollectionTable(name = "annotations", schema = "ia",joinColumns = @JoinColumn(name = "md_id", nullable = true))
    @Column(name="annotations", columnDefinition="TEXT")
    public List<String> annotations;

    /**
     * Parameters
     */
    @ElementCollection(targetClass = String.class)
    @CollectionTable(name = "arguments", schema = "ia",joinColumns = @JoinColumn(name = "md_id", nullable = true))
    @Column(name="arguments", columnDefinition="TEXT")
    public List<String> arguments;
    /**
     * Generics
     */
    @ElementCollection(targetClass = String.class)
    @CollectionTable(name = "generics", schema = "ia",joinColumns = @JoinColumn(name = "md_id", nullable = true))
    @Column(name="generics", columnDefinition="TEXT")
    public Set<String> generics;
    public Integer starts;
    public Integer ends;

    /**
     * Super class
     */
    @Column(name="superClassPath", columnDefinition="TEXT")
    public String superClassPath;
    public Boolean isInTest;
    public Boolean isTestCase;

    /**
     * changed lines. Line number starts from the top of the file.
     * e.g.,
     * Line 10: True (= modified)
     * Line 11: False (= not modified)
     */
    @ElementCollection(targetClass = Boolean.class, fetch=FetchType.EAGER)
    @CollectionTable(name="changeLine",schema = "ia",joinColumns = @JoinColumn(name = "md_id", nullable = true))
    @MapKeyColumn(name="changeLine_key")
    @Column(name="changedLine_value")
    public Map<Integer, Boolean> changedLines;//lineNo, isChange

    // @Transient
    /**
     * refactorings that happens in this method
     */
    @ElementCollection(targetClass = String.class, fetch=FetchType.EAGER)
    @CollectionTable(name="inherentRefactoring",schema = "ia",joinColumns = @JoinColumn(name = "md_id", nullable = true))
    @MapKeyColumn(name="inherentRefactoring_key")
    @Column(name="inherentRefactoring_value", columnDefinition="TEXT")
    public Map<Integer, String> inherentRefactorings;//lineNo, refactorings
    //Test only
    // @Transient
    /**
     * refactorings affecting this method (outside of this method)
     */
    @ElementCollection(targetClass = String.class, fetch = FetchType.EAGER)
    @CollectionTable(name="directRefactoring",schema = "ia",joinColumns = @JoinColumn(name = "md_id", nullable = true))
    @MapKeyColumn(name="directRefactoring_key")
    @Column(name="directRefactoring_value", columnDefinition="TEXT")
    public Map<Integer, String> directRefactorings;//lineNo, refactorings

    // @Transient
    /**
     * We do not use this as of this study
     */
    @ElementCollection(targetClass = String.class, fetch=FetchType.EAGER)
    @CollectionTable(name="indirectRefactoring",schema = "ia",joinColumns = @JoinColumn(name = "md_id", nullable = true))
    @MapKeyColumn(name="indirectRefactoring_key")
    @Column(name="indirectRefactoring_value", columnDefinition="TEXT")
    public Map<Integer, String> indirectRefactorings;//lineNo, refactorings


    public MethodDefinition4DB(MethodDefinition md){
        this.signature = md.signature;
        this.anotherSignature = md.anotherSignature;
        this.fileName = md.fileName;
        this.className = md.className;
        this.packageName = md.packageName;
        this.methodName = md.methodName;
        this.annotations = md.annotations;
        this.arguments = md.arguments;
        this.generics = md.generics;
        this.starts = md.start;
        this.ends = md.end;
        this.superClassPath = md.superClassPath;
        this.changedLines = md.changedLines;
        if(md.inherentRefactorings != null){
            this.inherentRefactorings = this.transformRefactoring(md.inherentRefactorings);
        }
        this.isInTest = md.isInTest();
        this.isTestCase = md.isTestCase();
        if(md instanceof TestMethodDefinition){
            TestMethodDefinition tm = (TestMethodDefinition) md;
            this.directRefactorings = this.transformRefactoring2(tm.directRefactorings);
            this.indirectRefactorings = this.transformRefactoring2(tm.indirectRefactorings);
        }

    }

    public MethodDefinition4DB(){
    }

    /**
     * This transform refactoring list into String.
     * To identify refactoring, we append hash code from refactoring instance
     * @param map
     * @return
     */
    private Map<Integer, String> transformRefactoring(Map<Integer, Set<Refactoring>> map){
        Map<Integer, String> out = new HashMap<>();
        for(Integer lineNo: map.keySet()){
            Set<Refactoring> refs = map.get(lineNo);
            if(refs.isEmpty()){
                continue;
            }
            else{
                String set = "";
                for(Refactoring r: refs){
                    set = set + "," +r.getRefactoringType().getDisplayName()+"@"+r.hashCode();
                }
                out.put(lineNo, set);
            }
        }
        return out;
    }
    /**
     * This behavior is the same as transformRefactoring but use Refactoring2
     * TODO: Use generics and delete this
     * @param map
     * @return
     */
    private Map<Integer, String> transformRefactoring2(Map<Integer, Set<Refactoring2>> map){
        Map<Integer, String> out = new HashMap<>();
        for(Integer lineNo: map.keySet()){
            Set<Refactoring2> refs = map.get(lineNo);
            if(refs.isEmpty()){
                continue;
            }
            else{
                String set = "";
                for(Refactoring2 r: refs){
                    set = set + "," +r.refactoring.getRefactoringType().getDisplayName()+"@"+r.hashCode() + "-" + r.whoMade;
                    System.out.println("set :: " + set);
                }
                out.put(lineNo, set);
            }
        }
        return out;
    }
}
